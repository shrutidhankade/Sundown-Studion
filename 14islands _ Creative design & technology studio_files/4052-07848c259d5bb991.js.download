(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4052],{85451:function(e,n,t){let r=t(81402);e.exports=function(e,n,t,a,o=60){if(void 0===a)return r(e,n,t);let i=1-t;return r(e,n,1-Math.pow(i,a/(1/o)))}},81402:function(e){e.exports=function(e,n,t){return e*(1-t)+n*t}},35799:function(e,n,t){"use strict";t.d(n,{Z:function(){return P}});var r=t(11527),a=t(50959),o=t(19095),i=t(13214),u=t(18678),s=t(92594),l=t(91306),c=t(20762),m=t(80202),v=t(21673),f=t(3982),p=t(95158),d=t.n(p),x=t(58684);let g=(0,x.g)({uTexture:null,uDisplacement:null,uPlaneSize:[1,1],uWindowSize:[0,0],uWinResolution:[1,1],uBorderRadius:1,uTime:0,uMouseEnter:new o.Vector2(-1,-1),uEnterTime:0,uEnterDirection:-1,uWaveStrength:0,uNoiseAmplitude:.2,uNoiseFrequency:.66,uNoiseSpeed:-.5,uNoiseOctaves:3,uEdgeBlurAmount:.8,uZoom:.06,uWaveFrequency:10,uWaveAmplitude:.2,uWaveSpeed:2,uOpacity:.2,uProgress:0,uParallax:0,uParallaxSpeed:0},"#define GLSLIFY 1\n// Fractal noise from https://github.com/yiwenl/glsl-fbm\n// Modified signature to accept num octaves as an optional 2nd parameter\n\n#define NUM_OCTAVES 5\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n    mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n    mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nfloat fbm(vec2 x, int numOctaves) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < numOctaves; ++i) {\n    v += a * noise(x);\n    x = rot * x * 2.0 + shift;\n    a *= 0.5;\n    }\n    return v;\n}\n\nfloat fbm(vec2 x) {\n    return fbm(x, NUM_OCTAVES);\n}\n\nuniform float uTime;\nuniform float uNoiseAmplitude;\nuniform float uNoiseFrequency;\nuniform int uNoiseOctaves;\nuniform float uNoiseSpeed;\nuniform float uProgress;\nuniform vec2 uMouseEnter;\nuniform float uEnterTime;\nuniform vec2 uPlaneSize;\nuniform vec2 uWindowSize;\n\nuniform float uEnterDirection;\n\nvarying float vNoise;\nvarying vec2 vUv;\n\n#define PI 3.1415926538\n\n// Distort edge in world pos to get uniform strength no matter image scale\nvec4 edgeWave(vec3 position, vec4 worlPos, float effect, float time, vec2 uv) {\n\n  // Wave Amplitude\n  float amp = pow(1.33 * max(0., uEnterTime + 1. - uTime  ), 11.0); // pow makes wave softer at the end - feels faster\n  float waveAmp = amp * 0.5;\n  float waveSpeed = 14. * -1. * uEnterDirection * (1. - effect);\n\n  // Frequency - keep consistent across sizes and aspect\n  float numWaves = 14.; // magic number - must match the MAX_DISTANCE to look good\n  vec2 freq = vec2(uPlaneSize.x / uWindowSize.x, uPlaneSize.y / uWindowSize.x) * 18.;\n  vec2 waveFreq = freq * 1.5;\n  \n  // CREATE NOISE\n  // large bend\n  float n = (cos((uv.x-uMouseEnter.x)*PI*2.*freq.x) + cos(((uv.y-uMouseEnter.y)*PI*2.)*freq.y)) * amp * effect;\n		// small waves\n		n += (cos((uv.x-uMouseEnter.x)*PI*2.*waveFreq.x + time * waveSpeed) + cos(((uv.y-uMouseEnter.y)*PI*2.)*waveFreq.y + time * waveSpeed)) * waveAmp * effect;\n\n  // Only affect vertices within MAX_DISTANCE\n  float MAX_DISTANCE = 0.06;\n  vec3 aspect = vec3(uPlaneSize.y/uPlaneSize.x, 1.0, 1.0);\n  vec2 vecDistance = vec2(uWindowSize.x / uPlaneSize.x * MAX_DISTANCE) / aspect.xy;\n  vec2 invDistance = clamp((vecDistance - pow(distance(uMouseEnter, uv), .9	)) / vecDistance, vec2(0.), vec2(1.));\n  vec3 dist = vec3(invDistance, 1.0);\n\n  worlPos.xyz -= position * 2. * n * dist * uEnterDirection;\n  return worlPos;\n}\n\nvoid main() {\n	vUv = uv;\n	vec3 pos = position;\n	float progress = 1. - uProgress;\n	\n	// scale up image in Y-axis\n	pos = mix(pos * vec3(1., .8, 1.), pos, uProgress);\n	\n	// distort in world pos\n	vec4 wPos = modelMatrix * vec4(pos, 1.);\n\n	// Distort mesh using Fractal noise\n	vNoise = fbm(wPos.xy * uNoiseFrequency + uTime * uNoiseSpeed, uNoiseOctaves);\n	wPos *= mix(1., 1. - vNoise * uNoiseAmplitude, progress);\n\n	// distort edge in world space\n	float effect = pow(clamp(uTime - uEnterTime, 0., 1.0), 2.0);\n  	wPos = edgeWave(pos, wPos, effect, uTime - uEnterTime, uv);\n\n	gl_Position = projectionMatrix * viewMatrix * wPos;\n}","#define GLSLIFY 1\nuniform sampler2D uTexture;\nuniform sampler2D uDisplacement;\nuniform vec2 uPlaneSize;\nuniform vec2 uWinResolution;\nuniform float uBorderRadius;\nuniform float uTime;\nuniform float uEdgeBlurAmount;\nuniform float uZoom;\nuniform float uWaveFrequency;\nuniform float uWaveAmplitude;\nuniform float uWaveSpeed;\nuniform float uOpacity;\nuniform float uProgress;\nuniform float uParallax;\nuniform float uParallaxSpeed;\nuniform float uWaveStrength;\n\nvarying vec2 vUv;\nvarying float vNoise;\n\n#define PI 3.14159265\n\nfloat roundRect(vec2 uv, vec2 size, float radius) {\n	return length(max(abs(uv) - size + radius, 0.0)) - radius;\n}\n\nfloat weight(float t, float log2radius, float gamma) {\n	return exp(-gamma * pow(log2radius-t,2.));\n}\n\nvec4 sampleBlured(sampler2D map, vec2 uv, float radius, float gamma) {\n	vec4 pix = vec4(0.);\n	float norm = 0.;\n\n	float log2radius = log2(radius);\n\n	// weighted integration over mipmap levels\n	for(float i = 0.; i < 10.; i += 0.5) {\n			float k = weight(i, log2radius, gamma);\n			pix += k * texture(map, uv, i);\n			norm += k;\n	}\n\n	// nomalize, and a bit of brigtness hacking\n	return pix * pow(norm, -0.95);\n}\n\nfloat smoothEdges(vec2 uv, float amount) {\n	uv = (2.0 * uv - 1.0);\n\n	float eps = 1e-6;\n\n	// mask each side\n	float topMask = 1.0 - uv.y;\n	float bottomMask = uv.y + 1.0;\n	float leftMask = uv.x + 1.0 + eps;\n	float rightMask = 1.0 - uv.x;\n\n	// combine masks\n	float squareMask = topMask * bottomMask * leftMask * rightMask;\n\n	// AA edge\n	float delta = fwidth(squareMask) * 2.;\n	return smoothstep(0.0, amount + delta, squareMask);\n}\n\nvoid main() {\n	// STEP 0 - Create a mask for the rounded corners\n	// TODO: see if alpha mask needed instead\n	vec2 halfSize = uPlaneSize * 0.5;\n	vec2 coord = vUv * uPlaneSize;\n	vec2 p = coord - halfSize;\n	float mask = 1. - roundRect(p, halfSize, uBorderRadius);\n\n	float progress = 1. - uProgress;\n\n	// STEP 1 - zoom and displace UV for more ripples on top of image\n	//////////////////////////////////////////////\n\n	// convert UV to [-1,1] instead of [0,1]\n	vec2 vUv2 = vUv;\n	vUv2 = (vUv2 * 2.) - 1.;\n	\n	// wave displace\n	float waveDisplace = (sin(vUv2.x * uWaveFrequency + uTime * uWaveSpeed) + 1.) * 0.5;\n	vUv2.y *= 1. - waveDisplace * uWaveAmplitude * progress;\n\n		// apply zoom /w parallax\n	vUv2 *= 1. - uZoom * progress - .25 * uParallaxSpeed;\n\n	// apply parallax\n	float parallax = (uParallax - .5) * 2. * uParallaxSpeed;\n	vUv2.y += parallax;\n\n	// convert back to [0,1] UVs\n	vUv2 = (vUv2 + 1.) * .5;\n\n	// Add ripples displacement\n	//////////////////////////////////////////////\n	// Use Screen Coords instead of UV Coords to avoid ripple scene shrink\n	vec2 scUv = gl_FragCoord.xy / uWinResolution.xy;\n    vec4 displacement= texture2D(uDisplacement, scUv);\n    float theta = displacement.r * 2. * PI;\n    vec2 direction = vec2(sin(theta), cos(theta));\n    vec2 vUv3 = vUv2 + direction * displacement.r * uWaveStrength;\n\n	// STEP 2 - blur image using weighted mipmap lookups\n	//////////////////////////////////////////////\n\n	float blur = mix(1.0, 10.0, progress);\n	float gamma = mix(1.0, .1, progress);\n	vec4 color = sampleBlured(uTexture, vUv3, blur, gamma);\n	\n	// STEP 3 - smooth edges of plane \n	// Apply noise to the blur amount for some irregular borders\n	// (re-using vertex noise for perf reasons)\n	//////////////////////////////////////////////\n	float alpha = smoothEdges(vUv, vNoise * progress * uEdgeBlurAmount); \n	vec4 sampledDiffuseColor = vec4(color.rgb, mix(alpha, alpha * uOpacity, progress) * mask * uProgress); \n\n	#ifdef DECODE_VIDEO_TEXTURE\n		// inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n\n	gl_FragColor = sampledDiffuseColor;\n\n	#include <colorspace_fragment>\n\n	// TEMP Simple image\n	// vec4 image = texture2D(uTexture, vUv);\n	// gl_FragColor = vec4(image.rgb, mask * uProgress);\n}");(0,i.e)({BlurryMaterial:g});let h=parseInt([d()["base-width"]]),y=new o.PlaneGeometry(1,1,128,128),w=new o.PlaneGeometry(1,1,1,1);var P=e=>{let{texture:n,index:t=0,materialRef:o,parallaxSpeed:p=0,inViewport:d,hasEdgeEffect:x,isVideo:P=!1,onPointerMove:S,onPointerEnter:E,onPointerLeave:T,onClick:M,...D}=e,b=6/h*(0,i.z)(e=>e.size.width),k=(0,i.z)(e=>e.size),{scaleMultiplier:z}=(0,c.hP)(),R=(0,a.useRef)(null),U=(0,a.useRef)({x:-1,y:-1,time:0}).current,W=(0,a.useCallback)(e=>{R.current=e,o&&(o.current=e)},[o]);(0,i.A)((e,n)=>{R.current&&(R.current.uTime+=n,R.current.uParallax=D.scrollState.progress)});let{pathname:A}=(0,m.useRouter)(),C=(0,v.Z)(),N=(0,f.Z)(e=>e.showJournalEntries),O=(0,f.Z)(e=>e.showCoverPlane),_="/journal"===A?C&&N:C;return(0,u.q_)({from:{p:0},to:{p:_?1:0},onChange:e=>{let{value:{p:n}}=e;R.current&&(R.current.uProgress=n,(0,i.l)())},config:{duration:_?3e3:O?500+500*Math.random():500,easing:_?s.M4:O?l.U2:l.u4},delay:_?300+150*t:O?50+100*Math.random():0}),(0,r.jsxs)("group",{...D,children:[(0,r.jsx)("mesh",{geometry:w,onPointerEnter:e=>{var n,t;null==E||E(e),x&&R.current&&R.current.uTime-U.time>.4&&(R.current.uMouseEnter.set((null===(n=e.uv)||void 0===n?void 0:n.x)||0,(null===(t=e.uv)||void 0===t?void 0:t.y)||0),R.current.uEnterTime=R.current.uTime,R.current.uEnterDirection=1,U.time=R.current.uTime)},onPointerMove:e=>{var n,t;x&&(U.x=(null===(n=e.uv)||void 0===n?void 0:n.x)||.5,U.y=(null===(t=e.uv)||void 0===t?void 0:t.y)||.5),null==S||S(e)},onPointerLeave:e=>{null==T||T(e),x&&R.current&&R.current.uTime-U.time>.4&&(R.current.uMouseEnter.set(U.x,U.y),R.current.uEnterTime=R.current.uTime,R.current.uEnterDirection=-1,U.time=R.current.uTime)},onClick:M,...d?{}:{raycast:()=>{}},visible:!1}),(0,r.jsx)("mesh",{geometry:y,children:(0,r.jsx)("blurryMaterial",{ref:W,uTexture:n,uPlaneSize:D.scale.xy.div(z),uWindowSize:[k.width,k.height],uParallaxSpeed:p,uBorderRadius:b,transparent:!0,defines:{DECODE_VIDEO_TEXTURE:P},depthTest:!1},g.key)})]})}},64052:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return E}});var r=t(11527),a=t(50959),o=t(20762),i=t(77733),u=t(29324),s=t(13214),l=t(19095),c=t(30421),m=t(85451),v=t.n(m),f=t(35799);let p=new l.PlaneGeometry,d=new l.MeshBasicMaterial({map:null,transparent:!0,blending:l.AdditiveBlending,depthTest:!1,depthWrite:!1}),x=(e,n,t,r,a,o)=>{let i=a[t];i.visible=!0,i.position.x=e,i.position.y=n,i.scale.x=i.scale.y=r,i.material.opacity=o},g=0,h=new l.Vector2(0,0),y=new l.Vector2(0,0),w=0,P=function(e,n,t,r,a,o){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:.1,u=arguments.length>7?arguments[7]:void 0;y.x=e.pointer.x*n/2,y.y=e.pointer.y*t/2;let s=e.timeStamp-w;Math.abs(y.x-h.x)<i&&Math.abs(y.y-h.y)<i||.01*s<u||(x(y.x,y.y,g,r,a,o),g=(g+1)%50,w=e.timeStamp),h.x=y.x,h.y=y.y},S=e=>{let{imageRef:n,hasReducedRipples:t,...m}=e,x=(0,o.D)(n),g=(0,a.useRef)(null),h=(0,a.useRef)(!1),y=(0,a.useRef)(!1),{scaleMultiplier:w}=(0,o.hP)(),S=(0,a.useRef)(-1),{viewport:E,size:T}=(0,s.z)(),M=(0,s.z)(e=>e.viewport.dpr),{uWaveStrength:D,waveSize:b,newWaveScale:k,waveRotation:z,waveVelocity:R,startOpacity:U,strengthLerp:W,speedLerp:A,minSpeed:C,minDistance:N,minTime:O}=(0,c.M4)("Ripples Effect",{uWaveStrength:{value:.14,min:0,max:1,step:.001,label:"wave strength"},waveSize:{value:3,min:0,max:20,step:.01},newWaveScale:{value:7,min:0,max:100,step:.01},waveRotation:{value:.1,min:0,max:2*Math.PI,step:.001},waveVelocity:{value:.05,min:0,max:1,step:1e-4},startOpacity:{value:.22,min:0,max:1,step:.01},strengthLerp:{value:.1,min:0,max:1,step:.01},speedLerp:{value:.1,min:0,max:1,step:.01},minSpeed:{value:0,min:0,max:1,step:.01},minDistance:{value:.005,min:0,max:1,step:.01},minTime:{value:.1,min:0,max:2,step:.01}}),_=(0,i.R)(m.scale.x/w*.5*M,m.scale.y/w*.5*M),q=(0,u.m)("/_next/static/media/ripplesBrush.31b49553.png");b=t?b/2:b,k=t?k/2:k;let I=b/m.scale.xy.min(),{meshes:F,scene:B}=(0,a.useMemo)(()=>{let e=new l.Scene,n=[];for(let t=0;t<50;t++){let t=d.clone();t.map=q;let r=new l.Mesh(p,t);r.visible=!1,r.rotation.z=2*Math.PI*Math.random(),e.add(r),n.push(r)}return{scene:e,meshes:n}},[q]),V=e=>{P(e,E.width,E.height,I,F,U,N,O)},j=(0,a.useRef)({x:0,y:0}),L=(0,a.useRef)({x:0,y:0}),Z=(0,a.useRef)(0);return(0,s.A)((e,n)=>{let{gl:t,camera:r,pointer:a}=e;if(g.current&&j.current&&L.current){if(n=Math.min(n,1/30),y.current&&F.filter(e=>e.visible).length){L.current.x=a.x*E.width/2,L.current.y=a.y*E.height/2;let[e,o]=[j.current.x,j.current.y],[i,u]=[L.current.x,L.current.y];h.current?Z.current=Math.max(C,v()(Z.current,Math.sqrt((i-e)**2+(u-o)**2),A,n)):Z.current=v()(Z.current,0,.005,n),j.current.x=L.current.x,j.current.y=L.current.y,F.forEach(e=>{e.visible&&(e.rotation.z+=2*n*z,e.material.opacity=v()(e.material.opacity,0,R,n),e.scale.x+=n*k,e.scale.y=e.scale.x,e.material.opacity<.002&&(e.visible=!1))}),t.setRenderTarget(_),t.render(B,r),g.current.uDisplacement=_.texture,t.setRenderTarget(null),(0,s.l)()}g.current.uWaveStrength=v()(g.current.uWaveStrength,D*Z.current*5,W,n),g.current.uWinResolution=new l.Vector2(T.width,T.height).multiplyScalar(Math.min(window.devicePixelRatio,M))}}),(0,r.jsx)(f.Z,{texture:x,materialRef:g,onPointerMove:e=>{V(e),(0,s.l)(),y.current=!0,clearTimeout(S.current)},onPointerEnter:()=>{h.current=!0,(0,s.l)(),clearTimeout(S.current)},onPointerLeave:()=>{S.current=setTimeout(()=>{y.current=!1},2e3),h.current=!1},hasEdgeEffect:!0,...m})};var E=e=>{let{element:n,...t}=e;return(0,r.jsx)(a.Suspense,{fallback:null,children:(0,r.jsx)(S,{imageRef:n,...t})})}}}]);